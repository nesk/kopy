{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":""},{"location":"#kopy","title":"Kopy","text":""},{"location":"#usage","title":"Usage","text":""},{"location":"#intellij-idea-or-android-studio-configuration","title":"IntelliJ IDEA or Android Studio configuration","text":""},{"location":"#enable-k2-compiler-in-the-ide-settings","title":"Enable K2 compiler in the IDE settings:","text":"<pre><code>File &gt; Settings &gt; Language &amp; Frameworks &gt; Kotlin &gt; Enable K2 mode\n</code></pre> <p>It is necessary to restart the IDE to do the next step.</p> <p></p>"},{"location":"#allow-third-party-k2-plugins","title":"Allow third party K2 plugins:","text":"<p>Popup the quick search with <code>shift + shift</code> and type <code>Registry...</code>, then search for:</p> <pre><code>kotlin.k2.only.bundled.compiler.plugins.enabled\n</code></pre> <p>And uncheck it.</p> <p></p>"},{"location":"#download","title":"Download","text":"<p>Apply the plugin in the <code>build.gradle.kts</code> or <code>build.gradle</code>:</p> <pre><code>plugins {\n    id(\"com.javiersc.kotlin.kopy\") version \"$version\"\n}\n</code></pre>"},{"location":"#plugin-configurations","title":"Plugin configurations","text":"<p>The extension <code>kopy</code> is available to configure the plugin:</p>"},{"location":"#visibility","title":"Visibility","text":"<p>The <code>visibility</code> option allows changing the visibility of the <code>copy</code> and <code>invoke</code> functions. The default value is <code>Auto</code>, which uses the same visibility the primary constructor has, as the original <code>copy</code> function does after Kotlin 2.0.20.</p> <p>Possible values:</p> <ul> <li><code>KopyVisibility.Auto</code> (Default): The visibility of the primary constructor is used.</li> <li><code>KopyVisibility.Public</code>: The visibility of the generated functions will be <code>public</code>.</li> <li><code>KopyVisibility.Internal</code>: The visibility of the generated functions will be <code>internal</code>.</li> <li><code>KopyVisibility.Protected</code>: The visibility of the generated functions will be <code>protected</code>.</li> <li><code>KopyVisibility.Private</code>: The visibility of the generated functions will be <code>private</code>.</li> </ul> <p>It is possible to have a more restrictive Kopy <code>copy</code> and <code>invoke</code> functions than the original one, for example by providing the <code>KopyVisiblity.Private</code> and the primary constructor being <code>public</code> or <code>internal</code>. The original <code>copy</code> function would be <code>public</code> or <code>internal</code> respectively, and the Kopy functions would be <code>private</code>.</p> <p>Note</p> <p>If the primary constructor visibility is more restrictive than the specified visibility, the primary constructor one is used.</p>"},{"location":"#example","title":"Example","text":"<pre><code>import com.javiersc.kotlin.kopy.args.KopyVisibility\n\nplugins {\n    id(\"com.javiersc.kotlin.kopy\") version \"$version\"\n}\n\nkopy {\n    visibility = KopyVisibility.Private\n}\n</code></pre>"},{"location":"#functions","title":"Functions","text":"<p>The <code>functions</code> option allows to decide which functions will be generated.</p> <p>Possible values:</p> <ul> <li><code>KopyFunctions.All</code> (default): Both, <code>copy</code> and <code>invoke</code> functions, will be generated.</li> <li><code>KopyFunctions.Copy</code>: Only the <code>copy</code> function will be generated.</li> <li><code>KopyFunctions.Invoke</code>: Only the <code>invoke</code> function will be generated.</li> </ul>"},{"location":"#example_1","title":"Example","text":"<pre><code>import com.javiersc.kotlin.kopy.args.KopyFunctions\n\nplugins {\n    id(\"com.javiersc.kotlin.kopy\") version \"$version\"\n}\n\nkopy {\n    functions = KopyFunctions.All\n}\n</code></pre>"},{"location":"#kopy-example","title":"Kopy Example","text":"<pre><code>import com.javiersc.kotlin.kopy.Kopy\n\nfun main() {\n    val house = House(\n        squareMeters = 100,\n        kitchen = Kitchen(\n            cat = Cat(\n                name = \"Garfield\",\n                age = 5,\n                numbers = listOf(1, 2, 3),\n            ),\n            squareMeters = 10,\n        ),\n    )\n    val house2: House = house.copy {\n        squareMeters = 200\n        kitchen.cat.name = \"Felix\"\n        kitchen.cat.age = 7\n        kitchen.cat.numbers.updateEach { it + 1 }\n        kitchen.squareMeters = 20\n    }\n\n    // House(squareMeters=200, kitchen=Kitchen(cat=Cat(name=Felix, age=7, numbers=[2, 3, 4]), squareMeters=20))\n    println(house2)\n}\n\n@Kopy\ndata class House(val squareMeters: Int, val kitchen: Kitchen)\n\n@Kopy\ndata class Kitchen(val cat: Cat, val squareMeters: Int)\n\n@Kopy\ndata class Cat(val name: String, val age: Int)\n</code></pre>"},{"location":"#features","title":"Features","text":""},{"location":"#copy-or-invoke","title":"<code>copy</code> or <code>invoke</code>","text":"<p><code>copy</code> and <code>invoke</code> create a new instance of the data class with the content specified. There is no difference between both functions.</p>"},{"location":"#set-or","title":"<code>set</code> or <code>=</code>","text":"<p><code>set</code> and <code>=</code> do the same, assigning a value.</p> <pre><code>val house2: House = house.copy {\n    kitchen.cat.name = \"Felix\"\n}\n\nval house3: House = house.copy {\n    kitchen.cat.name.set(\"Felix\")\n}\n</code></pre>"},{"location":"#update","title":"<code>update</code>","text":"<p><code>update</code> is a lambda which allows updating the value of the property while having access to the current value.</p> <pre><code>val house2: House = house.copy {\n    kitchen.cat.name.update { name -&gt; \"$name Jr.\" }\n}\n</code></pre>"},{"location":"#updateeach","title":"<code>updateEach</code>","text":"<p><code>updateEach</code> is a lambda that allows updating the values of an <code>Iterable</code> while having access to the current value of each element.</p> <pre><code>val house2: House = house.copy {\n    kitchen.cat.numbers.updateEach { it + 1 }\n}\n</code></pre>"},{"location":"#kotlin-multiplatform","title":"Kotlin Multiplatform","text":"<p>Kopy is compatible with Kotlin Multiplatform projects if it is used exclusively on projects that applies the plugin.</p> <p>Calling <code>copy</code> or <code>invoke</code> functions from Swift, or anything that is not Kotlin with the Kopy plugin applied, will not work.</p>"},{"location":"#kopykat-comparison","title":"KopyKat comparison","text":"<p>Kopy uses the K2 compiler plugin whereas KopyKat uses KSP to generate code, as a consequence there are different advantages and disadvantages.</p>"},{"location":"#advantages","title":"Advantages","text":"<ul> <li>Kopy\u2019s code generation is faster than KopyKat\u2019s</li> <li>Kopy does not need to run any Gradle task to get feedback on the IDE:<ul> <li>Autocompletion shows the <code>copy</code> and <code>invoke</code> functions instantly after annotating a data class   with <code>@Kopy</code> annotation.</li> <li>Removing the <code>@Kopy</code> annotation instantly removes the <code>copy</code> and <code>invoke</code> functions without   running a Gradle task or manually deleting the <code>build</code> directory of a project.</li> <li>As it is not necessary to assemble/build the project, the feedback loop is faster.</li> </ul> </li> <li>Build time should be better too (not tested).</li> <li>Kopy only adds 5 or 6 functions/properties to each data class,   whereas KopyKat needs to generate builders and the   functions/properties match the number of properties in the data class.   In the future, the number of properties Kopy adds to each data class will be reduced to 1 or 2.</li> </ul>"},{"location":"#disadvantages","title":"Disadvantages","text":"<p>Similar to Kotlin Power Assert, this plugin works on the call site, so it modifies the body of the <code>copy</code> or <code>invoke</code> lambdas. That means the plugin must be applied to get it working, so it is not a good idea to use it in a library or an SDK as it will force the users to apply the plugin. KopyKat generates all the builders, so it does not have this limitation.</p> <p>An error is shown in the IDE or at compilation time if the plugin is not applied and the <code>copy</code> or <code>invoke</code> function from a class in another module is called, but it will not appear if the consumer is a Java application/library.</p>"},{"location":"#how-it-works","title":"How it works","text":"<p>The plugin transforms the lambda into what a developer would do manually with <code>copy</code> functions, that means the <code>copy</code> or <code>invoke</code> lambda can only work if the plugin is applied to the project it is being called.</p> <p>If the plugin is not applied, the <code>copy</code> and <code>invoke</code> function calls will be marked as errors. Don\u2019t suppress them without applying the plugin as they will not work.</p> <p>It is not necessary to suppress them manually, the Gradle plugin will suppress them automatically.</p> <p>There is no reflection or mutability, the class will have some new functions and properties added.</p> <p>The number is limited to 6 independently of the number of properties the data class has:</p> <ul> <li><code>copy</code> function</li> <li><code>invoke</code> function</li> <li><code>_atomic</code> property</li> <li><code>set</code> function</li> <li><code>update</code> function</li> <li><code>updateEach</code> function</li> </ul> <p>When the Context Parameters feature is available, the number of properties and methods added to the data class will be reduced to only 1 or 2:</p> <ul> <li><code>copy</code> function [optional]</li> <li><code>invoke</code> function [optional]</li> </ul> <p>A new <code>CopyScope</code> will be created, and it will be used to store the rest of properties, and it will be added as a context parameter to the <code>copy</code> and <code>invoke</code> lambdas:</p> <pre><code>data class House(val squareMeters: Int, val kitchen: Kitchen) {\n\n    fun copy(block: CopyScope.() -&gt; Unit): T = ...\n\n    operator fun invoke(block: CopyScope.() -&gt; Unit): T = ...\n}\n</code></pre>"},{"location":"CHANGELOG/","title":"Changelog","text":""},{"location":"CHANGELOG/#0702020-2024-08-29","title":"0.7.0+2.0.20 - 2024-08-29","text":""},{"location":"CHANGELOG/#fixed","title":"Fixed","text":"<ul> <li>type mismatch errors inside the <code>copy</code> function are not shown</li> <li>Kotlin Multiplatform support</li> </ul>"},{"location":"CHANGELOG/#updated","title":"Updated","text":"<ul> <li><code>com.javiersc.hubdle:hubdle-version-catalog -&gt; 0.3.7</code></li> <li><code>com.javiersc.hubdle:com.javiersc.hubdle.gradle.plugin -&gt; 0.7.8</code></li> </ul>"},{"location":"CHANGELOG/#0602020-2024-08-27","title":"0.6.0+2.0.20 - 2024-08-27","text":""},{"location":"CHANGELOG/#added","title":"Added","text":"<ul> <li>Kotlin Multiplatform support</li> </ul>"},{"location":"CHANGELOG/#0502020-2024-08-26","title":"0.5.0+2.0.20 - 2024-08-26","text":""},{"location":"CHANGELOG/#added_1","title":"Added","text":"<ul> <li><code>KopyFunctions</code> to set the functions that will be generated</li> <li>report Kopy uses a different Kotlin version than the project</li> </ul>"},{"location":"CHANGELOG/#0402020-2024-08-25","title":"0.4.0+2.0.20 - 2024-08-25","text":""},{"location":"CHANGELOG/#added_2","title":"Added","text":"<ul> <li><code>KopyVisibility</code> to set the visibility of the generated functions</li> </ul>"},{"location":"CHANGELOG/#0302020-2024-08-24","title":"0.3.0+2.0.20 - 2024-08-24","text":""},{"location":"CHANGELOG/#added_3","title":"Added","text":"<ul> <li>Atomic library is added automatically to the project when the plugin is applied</li> <li>Kopy runtime library is added automatically to the project when the plugin is applied</li> </ul>"},{"location":"CHANGELOG/#removed","title":"Removed","text":"<ul> <li><code>Kopyable</code> interface</li> <li><code>_initKopyable</code> function from Kopyable interface</li> <li><code>getKopyableReference</code> function from Kopyable interface</li> <li><code>setKopyableReference</code> function from Kopyable interface</li> </ul>"},{"location":"CHANGELOG/#updated_1","title":"Updated","text":"<ul> <li><code>com.javiersc.hubdle:hubdle-version-catalog -&gt; 0.3.6</code></li> <li><code>com.javiersc.hubdle:com.javiersc.hubdle.gradle.plugin -&gt; 0.7.7</code></li> <li><code>com.javiersc.kotlin:kotlin-compiler-test-extensions -&gt; 0.3.0+2.0.20</code></li> <li><code>com.javiersc.kotlin:kotlin-compiler-extensions -&gt; 0.3.0+2.0.20</code></li> </ul>"},{"location":"CHANGELOG/#0202010-2024-08-19","title":"0.2.0+2.0.10 - 2024-08-19","text":""},{"location":"CHANGELOG/#added_4","title":"Added","text":"<ul> <li><code>kopy</code> and <code>invoke</code> calls are now marked as errors if the plugin is not applied to the project.</li> </ul>"},{"location":"CHANGELOG/#updated_2","title":"Updated","text":"<ul> <li><code>com.javiersc.hubdle:hubdle-version-catalog -&gt; 0.3.5</code></li> <li><code>com.javiersc.hubdle:com.javiersc.hubdle.gradle.plugin -&gt; 0.7.6</code></li> </ul>"},{"location":"CHANGELOG/#0112010-2024-08-16","title":"0.1.1+2.0.10 - 2024-08-16","text":""},{"location":"CHANGELOG/#updated_3","title":"Updated","text":"<ul> <li><code>gradle -&gt; 8.10</code></li> <li><code>com.javiersc.hubdle:hubdle-version-catalog -&gt; 0.3.4</code></li> <li><code>com.javiersc.hubdle:com.javiersc.hubdle.gradle.plugin -&gt; 0.7.4</code></li> <li><code>com.javiersc.kotlin:kotlin-compiler-test-extensions -&gt; 0.2.0+2.0.10</code></li> <li><code>com.javiersc.kotlin:kotlin-compiler-extensions -&gt; 0.2.0+2.0.10</code></li> </ul>"},{"location":"projects/kopy-compiler/kopy-compiler/","title":"Module kopy-compiler","text":""},{"location":"projects/kopy-runtime/kopy-runtime/","title":"Module kopy-runtime","text":""}]}